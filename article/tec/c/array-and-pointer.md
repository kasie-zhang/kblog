---
title: C 数组和指针
date: 2022-02-21
cover: /img/cover/101.webp
sidebar: 'auto'
categories:
- 笔记
- C 语言
tags:
- C
publish: true
permalink: /101
---

> 第 101 篇文章
<!-- more -->

人们通常借助计算机完成大量数据操作。通常，数组能够高效便捷地处理这种数据。

## Scala Variable
只存储单个值的变量有时也称为 `标量变量` (Scala Variable)。形式如下：

```c
int x = 1;
```
## Array Initialize
用以逗号分隔的值列表(用花括号括起来)初始化数组，各值之间用逗号分隔。在逗号之间可以使用空格。

```c
int arr[3] = {1,2,3};
```
使用数组之前**必须初始化**它，与普通变量类似，在使用数组元素之前，必须先给它们赋初值。编译器使用的值是内存相应位置上的现有值。

举个例子：未初始化时，编译器使用的是内存相应位置现有的值，输出不确定。
```c
#include<stdio.h>
#define SIZE 4
int main(){
    int data[SIZE]; /* 未初始化数组 */
    
    for(int i = 0; i < SIZE; i++){
        printf("%d %14d\n", i, data[i]);
    }
}
```

**当初始化列表中的值少于数组元素个数时，编译器会把剩余的元素都初始化为 0 。**

:::tip 总结
1. 不初始化数组，数组元素存储的都是垃圾值。
2. 部分初始化数组，剩余的元素都被初始化为0。
:::

## Read-Only Array
使用 `const` 声明数组，程序只能从数组中检索值，不能把新值写入数组。

```c
const int arr[3] = {1,2,3};
```

## Designated Initializer
C99 新增特性：**指定初始化器**(designated initializer)。利用该特性可以初始化指定位置的元素。

举个例子：数组长度为10，元素类型为 int 型，将第二个元素初始化为2，第三个元素初始化为3，第五个元素初始化为5，最后一个元素初始化为 10

```c
/* 传统语法 */
int arr[10] = {0,2,3,0,5,0,0,0,0,10};

/* 指定初始化器 */
int arr[10] = {[1]=2, 3, [4]=5, [9]=10};


/* 指定初始化器语法 - 1.如果再次初始化指定的元素，那么最后的初始化会取代之前的初始化 */
int arr[5] = {1,2,3,[1]=2};
// {2,2,3,0,0}

/* 指定初始化器语法 - 2.如果指定初始化器后面有更多的值，那么后面这些值会被用于初始化指定元素后面的元素 */
int arr[5] = {[1]=2, 3};
// {0,2,3,0,0}
```

指定初始化器的**两大特性**：
1. 如果再次初始化指定的元素，那么最后的初始化会取代之前的初始化。
2. 如果指定初始化器后面有更多的值，那么后面这些值会被用于初始化指定元素后面的元素。

## Array Element Assignment
声明数组后，可以借助数组下标给数组元素赋值。C 不允许把数组作为一个单元赋值给另一个数组。

谨防**数组下标超过边界**，C 信任程序员能编写正确的代码，不检查边界，这样程序运行速度更快。

:::tip Tip
在声明数组时使用**符号常量**来表示数组的大小。
:::

## VLA(Variable-Length Array)
C99 创建了一种新型数组，称为变长数组(variable-length array)，简称 VLA(C11 放弃了这一创新的举措，把 VLA 设定为可选，而不是语言必备的特性)

变长数组中的“变”不是指可以修改已创建数组的大小。一旦创建了变长数组，它的大小则保持不变。这里的“变”指的是：在创建数组时，可以使用变量指定数组的维度。这意味着变长数组的大小延迟到程序运行时才确定。

```c
int n = 10;
int arr[n];     // C99 之前不允许
```
## Multi-dimensional Arrays
指针提供了一种以符号形式使用地址的方法，因为计算机硬件指令非常依赖地址，指针在某种程度上把程序员想要传达的指令以更接近机器的方式表达。
因此使用指针的程序更有效率。数组表示法其实实在变相地使用指针。

```c
int arr[10];
arr = &arr[0];  // 数组名是该数组首元素的地址
```
`arr` 和 `&arr[0]` 都是**常量**，在程序运行的过程中不会改变。但是可以把它们赋值给指针变量，然后可以修改指针变量的值。

转换说明 `%p` 通常以十六进制显示指针的值。

指针加 1 指的是增加一个**存储单元**，对于数组而言，加 1 后的地址是下一个元素的地址，而不是下一个字节的地址。这是为什么必须声明指针所指向对象类型的原因之一。

在指针前使用 `*运算符`(解引用运算符)可以得到该指针所指向对象的值。

```c
/* 下列等式体现了C语言的灵活性 */
int date[10];
date + 2 == &date[2];   // 相同的地址
*(date + 2) == date[2]; // 相同的值
```

:::warning 注意 * 预算符 的优先级
1. 间接运算符 `*` 的优先级高于 `+`。

`*(date + 2)` ==> date 第三个元素的值。

`*date + 2` ==> date 第一个元素的值加2。

2. 间接运算符 `*` 和 `++` 的优先级相同，但是结合律是从右到左。

`total += *start++` ----> `total += *(start++)` 意味着先把指针指向位置上的值加到 total 上，然后再递增指针。
:::


数组表示法和指针表示法是两种等效的方法。 `*(days + index)` 与 `days[index]` 相同。`int *ar` 和 `int ar[]` 形式都表示 ar 是一个指向 int 的指针。


## Pointer Manipulation
- **赋值**：把地址赋给指针。
- **解引用**：*运算符给出指针指向地址上存储的值。
- **取址**：指针变量也有自己的地址和值。
- **指针和整数相加**：可以使用+运算符把指针与整数相加，或整数与指针相加。
- **递增指针**：递增指向数组元素的指针可以让该指针移动至数组的下一个元素。
- **指针减去一个整数**：可以使用-运算符从一个指针中减去一个整数。
- **递减指针**：除了递增指针也可以递减指针。
- **指针求差**：可以计算两个指针的差值。ptr2 - ptr1 得 2，表示这两个指针所指向的两个元素相隔两个int，而不是2字节。
- **比较**：使用关系运算符可以比较两个指针的值。

:::warning 指针使用前务必初始化
千万不要解引用未初始化的指针。 
```c
int *ptr;   // 未初始化的指针
*ptr = 5;   // 严重的错误
```
创建一个指针时，系统只分配了存储指针本身的内存，并未分配存储数据的内存。因此，在使用指针之前，必须先用已分配的地址初始化它。
:::

## Array Function
编写一个处理基本类型的函数时，通常都是传递数值，只有程序需要在函数中改变数值时，才会传递指针。对于数组别无选择，必须传递指针，因为这样做效率更高。

若编写的函数不用修改数组，那么在声明数组形参时最好使用 `const`。如果在函数中不小心更改了数组元素值，编译器会捕获这个错误，并生成一条错误信息。

举个例子：
```c
int arr[5] = {1,2,3,4,5};
const double *pd = arr;     // pd 指向的 int 类型的值声明为 const，这表明不能使用 pd 来更改它所指向的值
*pd = 2;                    // 不允许，Error: Assignment of read-only location
pd[0] = 2;                  // 不允许
arr[0] = 2;                 // 允许，因为 arr 未被 const 限定
```
无论是使用指针表示法还是数组表示法，都不允许使用 pd 修改它所指向数据的值。但是要注意，因为 arr 并未被声明为 const，所以仍然可以通过 arr 修改元素的值。另外可以让别处，但仍无法修改指向地址所存储的值。

:::danger 注意区分 const 所在位置
`const double * pc = rates;`        把 pc 指向的 double 类型的值声明为 const。

`double const * pc = rates;`        声明并初始化一个不能指向别处的指针。但可以改变指向地址上的值。

`const double const * pc = rates;`  该指针既不能更改它所指向的地址，也不能修改指向地址上的值。
:::




**把 const 数据或非 const 数据的地址初始化未指向 const 的指针或为其赋值是合法的**：
```c
double rates[5] = {1,2,3,4,5};
const double locked[4] = {1,2,3,4};
const double * pc = rates;              // 有效
pc = locked[3];                         // 有效
pc = &rates[3];                         // 有效
```

**只能把非 const 数据的地址赋给普通指针**：
```c
double rates[5] = {1,2,3,4,5};
const double locked[4] = {1,2,3,4};
double * pnc = rates;                   // 有效
pnc = locked;                           // 无效。否则 pnc 指针就能改变 const 数组中的数据。
pnc = &rates[3];                        // 有效
```

**不应该把 const 数组名作为实参传递给 func() 函数**。

## Pointer and Multi-dimensional
![](/img/2022/101_1.png)

**指向多维数组的指针**：
- `int (*pz)[n]` pz 为指向一个数组的指针，该数组每列含有 n 个 int 类型值。([ ]的优先级高于*)
- `int * pax[2]` pax 是一个内含两个指针元素的数组。
- `ptr[m][n]` 等价于 `*(*(ptr+m)+n)`

**指针的兼容性**：
- 指针之间的赋值比数值类型之间的赋值要严格
- 把 const 指针赋给 非 const 指针不安全
- 把非 const 指针赋给 const 指针没问题，前提是只进行**一级解引用**

```c
int x = 20;
const int y = 23;
int * p1 = &x;
const int * p2 = &y;
const int ** pp2;
p1 = p2;                // 不安全，把 const 指针赋给非 const 指针
p2 = p1;                // 有效
pp2 = &p1;              // 不安全，嵌套指针类型赋值
```

```c
const int **pp2;
int *p1;
const int n = 13;
pp2 = &p1;              // 允许，但这导致 const 限定符失效；(根据第一行，不能通过 **pp2 修改它所指向的内容)
*pp2 = &n;              // 有效，这将导致 p1 指向 n
*p1 = 10;               // 有效，但这将改变 n 的值；(根据第三行，不能修改 n 的值)
// pp2 --> p1 --> n
```

标准规定了通过非 const 指针更改 const 数据是**未定义**的，不同编译器给出的结果可能不同，且都会给出指针类型不兼容的警告。
当然，可以忽略这些警告，但是最好不要相信程序运行的结果，这些结果都是未定义的。

:::tip C const 和 C++ const
C 和 C++ 中 const 的用法很相似，但是并不完全相同。 

区别之一是，C++ 允许在声明数组大小时使用 const 整数，而 C 不允许。

```c
const int y;
const int * p2 = &y;
int * p1;
p1 = p2;                // C++ 不允许这么做，但是 C 可能只给出警告
```
区别之二是，C++ 的指针赋值检查更加严格。C++ 不允许把 const 指针赋给 const 指针。而 C 允许这么做。但是如果通过 p1 更改 y，其行为是未定义的。
:::

## Function and Multi-dimensional
声明一个处理二维数组的函数：
```c
#include<stdio.h>
#define ROWS 3
#define COLS 4

void sum_rows(int ar[][COLS], int rows);    // 第一个括号是空的。空的方括号表明 pt 是一个指针
void sum_cols(int [][COLS], int rows);      // 省略形参名，没问题
int sum2d(int (*ar)[COLS], int rows);       // 另一种语法，ar 是一个指向数组(内含 COLS 个 int 类型值)的指针
int sum4d(int ar[][10][20][30], int rows);  // 声明一个指向 N 维数组的指针时，只能省略最左边方括号中的值
// 因为第一对方括号只用于表明这是一个指针。而其他方括号则用于描述指针所指向数据对象的类型
```

## Compound Literal
C99 新增了`复合字面量`(Compound Literal)。字面量是除符号常量外的常量。例如，5 是 int 类型自面量，81.1是 double 类型字面量。
发布 C99 的委员会认为，如果有代表数组和结构内容的复合字面量，在编程时会更方便。

方便体现在：省去创建数组的步骤，直接将信息传入函数。复合字面量是**提供临时需要的值**的一种手段，具有块作用域。

因为复合字面量是匿名的，所有不能先创建然后使用它，必须在创建的同时使用它，使用指针记录地址就是一种方法。

举个例子：
```c
int arr[2] = {1,2};     // 普通数组声明
(int [2]){10,20};       // 复合字面量，去掉声明中的数组名，留下的 int[2] 就是复合字面量的类型名

int * pt1;
pt1 = (int [2]){10,20}; // 使用指针记录复合字面量的地址；复合字面量的类型名代表首元素的地址
```