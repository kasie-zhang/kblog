---
title: 字节序的大端和小端
date: 2022-03-10
cover: /img/cover/111.webp
sidebar: 'auto'
categories:
 - 笔记
tags:
 - 计算机基础
 - 字节序
publish: true
permalink: /article/111
---

> 第 111 篇文章
<!-- more -->

在 C 语言中，开发人员需要关心的问题是大小字节序的问题，俗称大端、小端。关于大小端，经常混淆，今天在这记录下大小端的记忆方法。

在叙述前，一起普及下几个常识性概念。

**字节序**：指多字节数据在计算机内存中存储或网络传输时各字节的存储顺序。

**网络字节序**：肯定是大端，是TCP/IP中规定好的一种数据表示格式。

**本地字节序**：指本地机器字节序，可能是大端也可能是小端。只与CPU相关，和内存、硬盘、操作系统都毫无关系。

x86 是小端字节序，ARM 是可配置的，UNIX 是大端字节序。

为使网络程序具有可移植性，使同样的 C 代码在大端和小端计算机上编译后都能正常运行，可以调用以下以下库函数做网络字节序和主机字节序的转换。

```c
#include <arpa/inet.h>  
/* 将 32 位的长整数从主机字节序转换为网络字节序。
   如果主机是小端，则函数将参数做相应的大小端转换然后返回；
   如果主机是大端，则函数不做转换，将参数原封不动的返回   */
uint32_t htonl(uint32_t hostlong);      
uint16_t htons(uint16_t hostshort);  
uint32_t ntohl(uint32_t netlong);  
uint16_t ntohs(uint16_t netshort);
```
这些函数名很好记：
- h表示host
- n表示network
- l表示32位长整数
- s表示16位短整数

举个例子：
```c
#include <stdio.h>
#include <arpa/inet.h>

int main(void)
{
    unsigned int x = 0x12345678;
    unsigned char *p = (unsigned char *) &x;
    printf("%x,%x,%x,%x\n", p[0], p[1], p[2], p[3]);

    unsigned int y = htonl(x);
    p = (unsigned char *)&y;
    printf("%x,%x,%x,%x\n", p[0], p[1], p[2], p[3]);
    return 0;
}
```
输出：

```md
78 56 34 12  
12 34 56 78
```
**即本机是小端字节序，而经过 htonl 转换为网络字节序，即大端。**


## 什么是大端，什么是小端
《程序设计实践》第9章中提到，“大端”和“小端”可以追溯到1726年的Jonathan Swift的《格列佛游记》，其中一篇讲到有两个国家因为吃鸡蛋究竟是先打破较大的一端还是先打破较小的一端而争执不休，甚至爆发了战争。
1981年10月，Danny Cohen的文章《论圣战以及对和平的祈祷》（On holy wars and a plea for peace）将这一对词语引入了计算机界。这么看来，所谓大端和小端，也就是big-endian和little-endian，其实是从描述鸡蛋的部位而引申到计算机地址的描述，也可以说，是从一个俚语衍化来的计算机术语。 稍有些英语常识的人都会知道，如果单靠字面意思来理解俚语，那是很难猜到它的正确含义的。在计算机里，对于地址的描述，很少用“大”和“小”来形容；对应地，用的更多的是“高”和“低”；很不幸地，这对术语直接按字面翻译过来就成了“大端”和“小端”，让人产生迷惑也不是很奇怪的事了。

试着这样记忆，大端 - **高尾端**； 小端 - **低尾端**

这样就好理解了：如果把一个数看成一个字符串，比如 0x11223344 看成 "11223344"，末尾则是 '\0'，显然，它的尾端是 44。

**高尾端（大端模式）表示将尾部放在高地址：**

```md
低地址 ---> 高地址
0x11 | 0x22 | 0x33 | 0x44
```

**低尾端（小端模式）表示将尾部放在低地址：**

```md
低地址 ---> 高地址
0x44| 0x33 | 0x22 | 0x11
```

## 判断大端和小端
写代码时，程序经常要判断机器是大端还是小端。常见的有两种策略。

### 1.编译期间判断
- 优点：利用GCC库带的头文件里的宏，运行效率高。
- 缺点：代码书写排版丑陋

```cpp
#if __BYTE_ORDER == __LITTLE_ENDIAN
   //小端，你的代码
#elif __BYTE_ORDER == __BIG_ENDIAN
  //大端, 你的代码
#endif
```


### 2.运行期间判断
- 优点：放到哪个平台运行都可以，平台兼容。
- 缺点：每次运行到这段代码都要耗费CPU指令判断。

```cpp
#include<stdio.h>
#include <cstdint>

bool is_little_endian() { 
    static uint32_t _endian_x_ = 1;
    // 内存从低位 --> 高位
    // 大端情况下，内存数据如下： 0x00 | 0x00 | 0x00 | 0x01
    // 小端情况下，内存数据如下： 0x01 | 0x00 | 0x00 | 0x00
    // 将32位数据强制转换为8位后；
    // 大端情况下，内存数据如下： 0x00
    // 小端情况下，内存数据如下： 0x01
    // 即小端输出1，大端输出0
    const uint8_t *tmp = reinterpret_cast<const uint8_t*>(&_endian_x_);
    return (tmp[0]); 
}
bool is_big_endian() { return !is_little_endian(); }
```

### 推荐的判断方式
建议在程序中使用**运行期间判断方式**，平台兼容，对性能的影响可以忽略不计。编译期间判断，虽然代码是平台兼容的，但是编译出来的可执行文件就不是平台兼容的，要么只能在大端上运行，要么在小端上运行。
